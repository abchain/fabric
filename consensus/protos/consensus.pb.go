// Code generated by protoc-gen-go. DO NOT EDIT.
// source: consensus.proto

/*
Package csprotos is a generated protocol buffer package.

It is generated from these files:
	consensus.proto

It has these top-level messages:
	ConsensusPurpose
	PurposeBlock
	PurposeTransactions
	ConsensusOutput
*/
package csprotos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import protos2 "github.com/abchain/fabric/protos"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ConsensusPurpose struct {
	// Types that are valid to be assigned to Out:
	//	*ConsensusPurpose_Txs
	//	*ConsensusPurpose_Nothing
	//	*ConsensusPurpose_Error
	Out isConsensusPurpose_Out `protobuf_oneof:"out"`
}

func (m *ConsensusPurpose) Reset()                    { *m = ConsensusPurpose{} }
func (m *ConsensusPurpose) String() string            { return proto.CompactTextString(m) }
func (*ConsensusPurpose) ProtoMessage()               {}
func (*ConsensusPurpose) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isConsensusPurpose_Out interface {
	isConsensusPurpose_Out()
}

type ConsensusPurpose_Txs struct {
	Txs *protos2.TransactionBlock `protobuf:"bytes,1,opt,name=txs,oneof"`
}
type ConsensusPurpose_Nothing struct {
	Nothing *google_protobuf1.Empty `protobuf:"bytes,2,opt,name=nothing,oneof"`
}
type ConsensusPurpose_Error struct {
	Error string `protobuf:"bytes,3,opt,name=error,oneof"`
}

func (*ConsensusPurpose_Txs) isConsensusPurpose_Out()     {}
func (*ConsensusPurpose_Nothing) isConsensusPurpose_Out() {}
func (*ConsensusPurpose_Error) isConsensusPurpose_Out()   {}

func (m *ConsensusPurpose) GetOut() isConsensusPurpose_Out {
	if m != nil {
		return m.Out
	}
	return nil
}

func (m *ConsensusPurpose) GetTxs() *protos2.TransactionBlock {
	if x, ok := m.GetOut().(*ConsensusPurpose_Txs); ok {
		return x.Txs
	}
	return nil
}

func (m *ConsensusPurpose) GetNothing() *google_protobuf1.Empty {
	if x, ok := m.GetOut().(*ConsensusPurpose_Nothing); ok {
		return x.Nothing
	}
	return nil
}

func (m *ConsensusPurpose) GetError() string {
	if x, ok := m.GetOut().(*ConsensusPurpose_Error); ok {
		return x.Error
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConsensusPurpose) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConsensusPurpose_OneofMarshaler, _ConsensusPurpose_OneofUnmarshaler, _ConsensusPurpose_OneofSizer, []interface{}{
		(*ConsensusPurpose_Txs)(nil),
		(*ConsensusPurpose_Nothing)(nil),
		(*ConsensusPurpose_Error)(nil),
	}
}

func _ConsensusPurpose_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConsensusPurpose)
	// out
	switch x := m.Out.(type) {
	case *ConsensusPurpose_Txs:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Txs); err != nil {
			return err
		}
	case *ConsensusPurpose_Nothing:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Nothing); err != nil {
			return err
		}
	case *ConsensusPurpose_Error:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Error)
	case nil:
	default:
		return fmt.Errorf("ConsensusPurpose.Out has unexpected type %T", x)
	}
	return nil
}

func _ConsensusPurpose_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConsensusPurpose)
	switch tag {
	case 1: // out.txs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(protos2.TransactionBlock)
		err := b.DecodeMessage(msg)
		m.Out = &ConsensusPurpose_Txs{msg}
		return true, err
	case 2: // out.nothing
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Empty)
		err := b.DecodeMessage(msg)
		m.Out = &ConsensusPurpose_Nothing{msg}
		return true, err
	case 3: // out.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Out = &ConsensusPurpose_Error{x}
		return true, err
	default:
		return false, nil
	}
}

func _ConsensusPurpose_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConsensusPurpose)
	// out
	switch x := m.Out.(type) {
	case *ConsensusPurpose_Txs:
		s := proto.Size(x.Txs)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConsensusPurpose_Nothing:
		s := proto.Size(x.Nothing)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConsensusPurpose_Error:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Error)))
		n += len(x.Error)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PurposeBlock struct {
	N uint64         `protobuf:"varint,1,opt,name=n" json:"n,omitempty"`
	B *protos2.Block `protobuf:"bytes,2,opt,name=b" json:"b,omitempty"`
}

func (m *PurposeBlock) Reset()                    { *m = PurposeBlock{} }
func (m *PurposeBlock) String() string            { return proto.CompactTextString(m) }
func (*PurposeBlock) ProtoMessage()               {}
func (*PurposeBlock) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PurposeBlock) GetN() uint64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *PurposeBlock) GetB() *protos2.Block {
	if m != nil {
		return m.B
	}
	return nil
}

type PurposeTransactions struct {
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
}

func (m *PurposeTransactions) Reset()                    { *m = PurposeTransactions{} }
func (m *PurposeTransactions) String() string            { return proto.CompactTextString(m) }
func (*PurposeTransactions) ProtoMessage()               {}
func (*PurposeTransactions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PurposeTransactions) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

type ConsensusOutput struct {
	// indicate the position the consensus tx corresponding to in
	// the whole chain (history), it may be an estimated value
	// unless out is block or blockhash (in that case, it is precise)
	// if out is error, this value MUST NOT be considered
	Position uint64 `protobuf:"varint,1,opt,name=position" json:"position,omitempty"`
	// Types that are valid to be assigned to Out:
	//	*ConsensusOutput_More
	//	*ConsensusOutput_Block
	//	*ConsensusOutput_Blockhash
	//	*ConsensusOutput_Nothing
	//	*ConsensusOutput_Error
	Out isConsensusOutput_Out `protobuf_oneof:"out"`
}

func (m *ConsensusOutput) Reset()                    { *m = ConsensusOutput{} }
func (m *ConsensusOutput) String() string            { return proto.CompactTextString(m) }
func (*ConsensusOutput) ProtoMessage()               {}
func (*ConsensusOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isConsensusOutput_Out interface {
	isConsensusOutput_Out()
}

type ConsensusOutput_More struct {
	More *PurposeTransactions `protobuf:"bytes,2,opt,name=more,oneof"`
}
type ConsensusOutput_Block struct {
	Block *protos2.Block `protobuf:"bytes,3,opt,name=block,oneof"`
}
type ConsensusOutput_Blockhash struct {
	Blockhash []byte `protobuf:"bytes,4,opt,name=blockhash,proto3,oneof"`
}
type ConsensusOutput_Nothing struct {
	Nothing *google_protobuf1.Empty `protobuf:"bytes,8,opt,name=nothing,oneof"`
}
type ConsensusOutput_Error struct {
	Error string `protobuf:"bytes,9,opt,name=error,oneof"`
}

func (*ConsensusOutput_More) isConsensusOutput_Out()      {}
func (*ConsensusOutput_Block) isConsensusOutput_Out()     {}
func (*ConsensusOutput_Blockhash) isConsensusOutput_Out() {}
func (*ConsensusOutput_Nothing) isConsensusOutput_Out()   {}
func (*ConsensusOutput_Error) isConsensusOutput_Out()     {}

func (m *ConsensusOutput) GetOut() isConsensusOutput_Out {
	if m != nil {
		return m.Out
	}
	return nil
}

func (m *ConsensusOutput) GetPosition() uint64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *ConsensusOutput) GetMore() *PurposeTransactions {
	if x, ok := m.GetOut().(*ConsensusOutput_More); ok {
		return x.More
	}
	return nil
}

func (m *ConsensusOutput) GetBlock() *protos2.Block {
	if x, ok := m.GetOut().(*ConsensusOutput_Block); ok {
		return x.Block
	}
	return nil
}

func (m *ConsensusOutput) GetBlockhash() []byte {
	if x, ok := m.GetOut().(*ConsensusOutput_Blockhash); ok {
		return x.Blockhash
	}
	return nil
}

func (m *ConsensusOutput) GetNothing() *google_protobuf1.Empty {
	if x, ok := m.GetOut().(*ConsensusOutput_Nothing); ok {
		return x.Nothing
	}
	return nil
}

func (m *ConsensusOutput) GetError() string {
	if x, ok := m.GetOut().(*ConsensusOutput_Error); ok {
		return x.Error
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConsensusOutput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConsensusOutput_OneofMarshaler, _ConsensusOutput_OneofUnmarshaler, _ConsensusOutput_OneofSizer, []interface{}{
		(*ConsensusOutput_More)(nil),
		(*ConsensusOutput_Block)(nil),
		(*ConsensusOutput_Blockhash)(nil),
		(*ConsensusOutput_Nothing)(nil),
		(*ConsensusOutput_Error)(nil),
	}
}

func _ConsensusOutput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConsensusOutput)
	// out
	switch x := m.Out.(type) {
	case *ConsensusOutput_More:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.More); err != nil {
			return err
		}
	case *ConsensusOutput_Block:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Block); err != nil {
			return err
		}
	case *ConsensusOutput_Blockhash:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Blockhash)
	case *ConsensusOutput_Nothing:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Nothing); err != nil {
			return err
		}
	case *ConsensusOutput_Error:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Error)
	case nil:
	default:
		return fmt.Errorf("ConsensusOutput.Out has unexpected type %T", x)
	}
	return nil
}

func _ConsensusOutput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConsensusOutput)
	switch tag {
	case 2: // out.more
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PurposeTransactions)
		err := b.DecodeMessage(msg)
		m.Out = &ConsensusOutput_More{msg}
		return true, err
	case 3: // out.block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(protos2.Block)
		err := b.DecodeMessage(msg)
		m.Out = &ConsensusOutput_Block{msg}
		return true, err
	case 4: // out.blockhash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Out = &ConsensusOutput_Blockhash{x}
		return true, err
	case 8: // out.nothing
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Empty)
		err := b.DecodeMessage(msg)
		m.Out = &ConsensusOutput_Nothing{msg}
		return true, err
	case 9: // out.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Out = &ConsensusOutput_Error{x}
		return true, err
	default:
		return false, nil
	}
}

func _ConsensusOutput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConsensusOutput)
	// out
	switch x := m.Out.(type) {
	case *ConsensusOutput_More:
		s := proto.Size(x.More)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConsensusOutput_Block:
		s := proto.Size(x.Block)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConsensusOutput_Blockhash:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Blockhash)))
		n += len(x.Blockhash)
	case *ConsensusOutput_Nothing:
		s := proto.Size(x.Nothing)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConsensusOutput_Error:
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Error)))
		n += len(x.Error)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ConsensusPurpose)(nil), "csprotos.ConsensusPurpose")
	proto.RegisterType((*PurposeBlock)(nil), "csprotos.PurposeBlock")
	proto.RegisterType((*PurposeTransactions)(nil), "csprotos.PurposeTransactions")
	proto.RegisterType((*ConsensusOutput)(nil), "csprotos.ConsensusOutput")
}

func init() { proto.RegisterFile("consensus.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 332 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x90, 0x4f, 0x4b, 0xf3, 0x40,
	0x10, 0xc6, 0xb3, 0x6f, 0xda, 0xd7, 0x66, 0x8c, 0xb4, 0xac, 0x50, 0x42, 0x8b, 0x52, 0x02, 0x62,
	0x0e, 0xb2, 0x85, 0xf6, 0xe4, 0xb5, 0x22, 0xe4, 0xa6, 0x2c, 0x7e, 0x81, 0x24, 0xa6, 0x6d, 0xb0,
	0xdd, 0x09, 0xfb, 0x07, 0xf4, 0x73, 0xf8, 0x75, 0x3d, 0xc8, 0x6e, 0x92, 0x5a, 0xa4, 0x17, 0x6f,
	0x33, 0x3b, 0xcf, 0xec, 0xef, 0x99, 0x07, 0x86, 0x05, 0x0a, 0x55, 0x0a, 0x65, 0x14, 0xab, 0x25,
	0x6a, 0xa4, 0x83, 0x42, 0xb9, 0x42, 0x4d, 0xc2, 0x75, 0x96, 0xcb, 0xaa, 0x68, 0xde, 0x27, 0xd3,
	0x0d, 0xe2, 0x66, 0x57, 0xce, 0x5d, 0x97, 0x9b, 0xf5, 0xbc, 0xdc, 0xd7, 0xfa, 0xa3, 0x19, 0xc6,
	0x9f, 0x04, 0x46, 0x0f, 0xdd, 0x47, 0xcf, 0x46, 0xd6, 0xa8, 0x4a, 0x7a, 0x07, 0xbe, 0x7e, 0x57,
	0x11, 0x99, 0x91, 0xe4, 0x7c, 0x11, 0x35, 0x4a, 0xc5, 0x5e, 0x64, 0x26, 0x54, 0x56, 0xe8, 0x0a,
	0xc5, 0x6a, 0x87, 0xc5, 0x5b, 0xea, 0x71, 0x2b, 0xa3, 0x0b, 0x38, 0x13, 0xa8, 0xb7, 0x95, 0xd8,
	0x44, 0xff, 0xdc, 0xc6, 0x98, 0x35, 0x44, 0xd6, 0x11, 0xd9, 0xa3, 0x25, 0xa6, 0x1e, 0xef, 0x84,
	0x74, 0x0c, 0xfd, 0x52, 0x4a, 0x94, 0x91, 0x3f, 0x23, 0x49, 0x90, 0x7a, 0xbc, 0x69, 0x57, 0x7d,
	0xf0, 0xd1, 0xe8, 0xf8, 0x1e, 0xc2, 0xd6, 0x8b, 0x23, 0xd1, 0x10, 0x88, 0x70, 0x76, 0x7a, 0x9c,
	0x08, 0x3a, 0x05, 0x92, 0xb7, 0xa8, 0x8b, 0xce, 0x9c, 0xd3, 0x71, 0x92, 0xc7, 0xb7, 0x70, 0xd9,
	0xae, 0x1e, 0xf9, 0x55, 0x74, 0x04, 0x7e, 0xf5, 0x6a, 0x4f, 0xf2, 0x93, 0x80, 0xdb, 0x32, 0xfe,
	0x22, 0x30, 0x3c, 0x5c, 0xfe, 0x64, 0x74, 0x6d, 0x34, 0x9d, 0xc0, 0xa0, 0x46, 0x55, 0xd9, 0x95,
	0x16, 0x77, 0xe8, 0xe9, 0x12, 0x7a, 0x7b, 0x94, 0x65, 0x0b, 0xbe, 0x62, 0x5d, 0xda, 0xec, 0x04,
	0x2e, 0xf5, 0xb8, 0x13, 0xd3, 0x1b, 0xe8, 0xe7, 0xd6, 0x99, 0xbb, 0xf3, 0xb7, 0x5d, 0x7b, 0xb6,
	0x9b, 0xd2, 0x6b, 0x08, 0x5c, 0xb1, 0xcd, 0xd4, 0x36, 0xea, 0xcd, 0x48, 0x12, 0xa6, 0x1e, 0xff,
	0x79, 0x3a, 0x8e, 0x78, 0xf0, 0xe7, 0x88, 0x83, 0x53, 0x11, 0xe7, 0xff, 0xdd, 0xe6, 0xf2, 0x3b,
	0x00, 0x00, 0xff, 0xff, 0xf8, 0x49, 0xde, 0x79, 0x47, 0x02, 0x00, 0x00,
}
