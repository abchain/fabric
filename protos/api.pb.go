// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

package protos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Specifies the block number to be returned from the blockchain.
type BlockNumber struct {
	Number               uint64   `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockNumber) Reset()         { *m = BlockNumber{} }
func (m *BlockNumber) String() string { return proto.CompactTextString(m) }
func (*BlockNumber) ProtoMessage()    {}
func (*BlockNumber) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

func (m *BlockNumber) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockNumber.Unmarshal(m, b)
}
func (m *BlockNumber) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockNumber.Marshal(b, m, deterministic)
}
func (m *BlockNumber) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockNumber.Merge(m, src)
}
func (m *BlockNumber) XXX_Size() int {
	return xxx_messageInfo_BlockNumber.Size(m)
}
func (m *BlockNumber) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockNumber.DiscardUnknown(m)
}

var xxx_messageInfo_BlockNumber proto.InternalMessageInfo

func (m *BlockNumber) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

// Specifies the current number of blocks in the blockchain.
type BlockCount struct {
	Count                uint64   `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockCount) Reset()         { *m = BlockCount{} }
func (m *BlockCount) String() string { return proto.CompactTextString(m) }
func (*BlockCount) ProtoMessage()    {}
func (*BlockCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

func (m *BlockCount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockCount.Unmarshal(m, b)
}
func (m *BlockCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockCount.Marshal(b, m, deterministic)
}
func (m *BlockCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockCount.Merge(m, src)
}
func (m *BlockCount) XXX_Size() int {
	return xxx_messageInfo_BlockCount.Size(m)
}
func (m *BlockCount) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockCount.DiscardUnknown(m)
}

var xxx_messageInfo_BlockCount proto.InternalMessageInfo

func (m *BlockCount) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*BlockNumber)(nil), "protos.BlockNumber")
	proto.RegisterType((*BlockCount)(nil), "protos.BlockCount")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 332 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0x4f, 0x4b, 0xf3, 0x40,
	0x10, 0xc6, 0x53, 0xde, 0xd7, 0x62, 0x47, 0x8b, 0x3a, 0x96, 0x22, 0x51, 0xa4, 0x2c, 0x08, 0x9e,
	0x12, 0xd0, 0x8b, 0x08, 0x1e, 0x8c, 0x96, 0xd2, 0x83, 0x7f, 0x50, 0xf1, 0xe0, 0x6d, 0x13, 0xa7,
	0x69, 0xb0, 0xdd, 0x5d, 0x76, 0x37, 0x48, 0x3f, 0x88, 0xdf, 0x57, 0xba, 0x9b, 0x88, 0x51, 0xea,
	0x29, 0x33, 0xcf, 0x3c, 0xcf, 0xe4, 0x97, 0x30, 0xd0, 0xe1, 0xaa, 0x88, 0x94, 0x96, 0x56, 0x62,
	0xdb, 0x3d, 0x4c, 0xb8, 0x39, 0xe1, 0xa9, 0x2e, 0x32, 0xaf, 0x86, 0xfb, 0xb9, 0x94, 0xf9, 0x8c,
	0x62, 0xd7, 0xa5, 0xe5, 0x24, 0xa6, 0xb9, 0xb2, 0x8b, 0x6a, 0x78, 0xf8, 0x73, 0xf8, 0xae, 0xb9,
	0x52, 0xa4, 0x8d, 0x9f, 0xb3, 0x23, 0xd8, 0x48, 0x66, 0x32, 0x7b, 0xbb, 0x2d, 0xe7, 0x29, 0x69,
	0xec, 0x43, 0x5b, 0xb8, 0x6a, 0xaf, 0x35, 0x68, 0x1d, 0xff, 0x7f, 0xa8, 0x3a, 0xc6, 0x00, 0x9c,
	0xed, 0x4a, 0x96, 0xc2, 0x62, 0x0f, 0xd6, 0xb2, 0x65, 0x51, 0x99, 0x7c, 0x73, 0xf2, 0xf1, 0x0f,
	0x3a, 0x77, 0x8a, 0x44, 0x36, 0xe5, 0x85, 0xc0, 0x21, 0xec, 0x8c, 0xc8, 0xba, 0x90, 0x13, 0xc6,
	0x62, 0x22, 0xb1, 0x1f, 0x79, 0x9c, 0xa8, 0xc6, 0x89, 0x86, 0x4b, 0xd6, 0xb0, 0xef, 0x05, 0x13,
	0x35, 0xfd, 0x2c, 0xc0, 0x33, 0xd8, 0xae, 0xd7, 0x24, 0x8b, 0x0a, 0x72, 0xb7, 0xe1, 0xf6, 0x62,
	0xd8, 0x6d, 0x88, 0x2c, 0xc0, 0x0b, 0xe8, 0xd6, 0x49, 0x4f, 0xbd, 0xea, 0xe5, 0xd8, 0x48, 0x3a,
	0x2f, 0x0b, 0x70, 0x0c, 0x38, 0x22, 0xfb, 0xa4, 0xb9, 0x30, 0x3c, 0xb3, 0x85, 0x14, 0xc9, 0x62,
	0x7c, 0x8d, 0x07, 0xbf, 0x76, 0x3c, 0x5a, 0x5d, 0x88, 0xfc, 0x99, 0xcf, 0x4a, 0x0a, 0xbf, 0xc0,
	0xbe, 0xc5, 0x58, 0x80, 0xe7, 0xb0, 0x3e, 0x22, 0x7b, 0x4f, 0xa4, 0xcd, 0x4a, 0x88, 0x5e, 0x1d,
	0x75, 0xb6, 0x1b, 0x32, 0x86, 0xe7, 0xc4, 0x02, 0xbc, 0x84, 0xad, 0x2a, 0x3b, 0x14, 0xaf, 0x4a,
	0x16, 0x7f, 0x7c, 0xc7, 0x8a, 0x15, 0x09, 0x7b, 0x19, 0xe4, 0x85, 0x9d, 0x96, 0x69, 0x94, 0xc9,
	0x79, 0xcc, 0x53, 0xf7, 0x7b, 0x63, 0x7f, 0x42, 0xfe, 0x2e, 0x4c, 0xea, 0x2f, 0xeb, 0xf4, 0x33,
	0x00, 0x00, 0xff, 0xff, 0x64, 0xc7, 0xda, 0x3d, 0x6d, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OpenchainClient is the client API for Openchain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OpenchainClient interface {
	// GetBlockchainInfo returns information about the blockchain ledger such as
	// height, current block hash, and previous block hash.
	GetBlockchainInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BlockchainInfo, error)
	// GetBlockByNumber returns the data contained within a specific block in the
	// blockchain. The genesis block is block zero.
	GetBlockByNumber(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*Block, error)
	// GetBlockCount returns the current number of blocks in the blockchain data
	// structure.
	GetBlockCount(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BlockCount, error)
	// returns a transaction by its txid
	GetTransactionByID(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*Transaction, error)
	// GetPeers returns a list of all peer nodes currently connected to the target
	// peer.
	GetPeers(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PeersMessage, error)
	// GetPeerEndpoint returns self peer node
	GetPeerEndpoint(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PeersMessage, error)
}

type openchainClient struct {
	cc *grpc.ClientConn
}

func NewOpenchainClient(cc *grpc.ClientConn) OpenchainClient {
	return &openchainClient{cc}
}

func (c *openchainClient) GetBlockchainInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BlockchainInfo, error) {
	out := new(BlockchainInfo)
	err := c.cc.Invoke(ctx, "/protos.Openchain/GetBlockchainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openchainClient) GetBlockByNumber(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/protos.Openchain/GetBlockByNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openchainClient) GetBlockCount(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BlockCount, error) {
	out := new(BlockCount)
	err := c.cc.Invoke(ctx, "/protos.Openchain/GetBlockCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openchainClient) GetTransactionByID(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/protos.Openchain/GetTransactionByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openchainClient) GetPeers(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PeersMessage, error) {
	out := new(PeersMessage)
	err := c.cc.Invoke(ctx, "/protos.Openchain/GetPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openchainClient) GetPeerEndpoint(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PeersMessage, error) {
	out := new(PeersMessage)
	err := c.cc.Invoke(ctx, "/protos.Openchain/GetPeerEndpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenchainServer is the server API for Openchain service.
type OpenchainServer interface {
	// GetBlockchainInfo returns information about the blockchain ledger such as
	// height, current block hash, and previous block hash.
	GetBlockchainInfo(context.Context, *empty.Empty) (*BlockchainInfo, error)
	// GetBlockByNumber returns the data contained within a specific block in the
	// blockchain. The genesis block is block zero.
	GetBlockByNumber(context.Context, *BlockNumber) (*Block, error)
	// GetBlockCount returns the current number of blocks in the blockchain data
	// structure.
	GetBlockCount(context.Context, *empty.Empty) (*BlockCount, error)
	// returns a transaction by its txid
	GetTransactionByID(context.Context, *wrappers.StringValue) (*Transaction, error)
	// GetPeers returns a list of all peer nodes currently connected to the target
	// peer.
	GetPeers(context.Context, *empty.Empty) (*PeersMessage, error)
	// GetPeerEndpoint returns self peer node
	GetPeerEndpoint(context.Context, *empty.Empty) (*PeersMessage, error)
}

func RegisterOpenchainServer(s *grpc.Server, srv OpenchainServer) {
	s.RegisterService(&_Openchain_serviceDesc, srv)
}

func _Openchain_GetBlockchainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenchainServer).GetBlockchainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Openchain/GetBlockchainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenchainServer).GetBlockchainInfo(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Openchain_GetBlockByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenchainServer).GetBlockByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Openchain/GetBlockByNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenchainServer).GetBlockByNumber(ctx, req.(*BlockNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _Openchain_GetBlockCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenchainServer).GetBlockCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Openchain/GetBlockCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenchainServer).GetBlockCount(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Openchain_GetTransactionByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenchainServer).GetTransactionByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Openchain/GetTransactionByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenchainServer).GetTransactionByID(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Openchain_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenchainServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Openchain/GetPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenchainServer).GetPeers(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Openchain_GetPeerEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenchainServer).GetPeerEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Openchain/GetPeerEndpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenchainServer).GetPeerEndpoint(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Openchain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Openchain",
	HandlerType: (*OpenchainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockchainInfo",
			Handler:    _Openchain_GetBlockchainInfo_Handler,
		},
		{
			MethodName: "GetBlockByNumber",
			Handler:    _Openchain_GetBlockByNumber_Handler,
		},
		{
			MethodName: "GetBlockCount",
			Handler:    _Openchain_GetBlockCount_Handler,
		},
		{
			MethodName: "GetTransactionByID",
			Handler:    _Openchain_GetTransactionByID_Handler,
		},
		{
			MethodName: "GetPeers",
			Handler:    _Openchain_GetPeers_Handler,
		},
		{
			MethodName: "GetPeerEndpoint",
			Handler:    _Openchain_GetPeerEndpoint_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}
