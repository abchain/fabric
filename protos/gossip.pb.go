// Code generated by protoc-gen-go. DO NOT EDIT.
// source: gossip.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Gossip struct {
	// all the gossip message (with different catalog) MUST share the
	// same series of seq
	Seq     uint64 `protobuf:"varint,1,opt,name=seq" json:"seq,omitempty"`
	Catalog string `protobuf:"bytes,2,opt,name=catalog" json:"catalog,omitempty"`
	// Types that are valid to be assigned to M:
	//	*Gossip_Dig
	//	*Gossip_Ud
	M isGossip_M `protobuf_oneof:"m"`
}

func (m *Gossip) Reset()                    { *m = Gossip{} }
func (m *Gossip) String() string            { return proto.CompactTextString(m) }
func (*Gossip) ProtoMessage()               {}
func (*Gossip) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

type isGossip_M interface {
	isGossip_M()
}

type Gossip_Dig struct {
	Dig *Gossip_Digest `protobuf:"bytes,3,opt,name=dig,oneof"`
}
type Gossip_Ud struct {
	Ud *Gossip_Update `protobuf:"bytes,4,opt,name=ud,oneof"`
}

func (*Gossip_Dig) isGossip_M() {}
func (*Gossip_Ud) isGossip_M()  {}

func (m *Gossip) GetM() isGossip_M {
	if m != nil {
		return m.M
	}
	return nil
}

func (m *Gossip) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Gossip) GetCatalog() string {
	if m != nil {
		return m.Catalog
	}
	return ""
}

func (m *Gossip) GetDig() *Gossip_Digest {
	if x, ok := m.GetM().(*Gossip_Dig); ok {
		return x.Dig
	}
	return nil
}

func (m *Gossip) GetUd() *Gossip_Update {
	if x, ok := m.GetM().(*Gossip_Ud); ok {
		return x.Ud
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Gossip) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Gossip_OneofMarshaler, _Gossip_OneofUnmarshaler, _Gossip_OneofSizer, []interface{}{
		(*Gossip_Dig)(nil),
		(*Gossip_Ud)(nil),
	}
}

func _Gossip_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Gossip)
	// m
	switch x := m.M.(type) {
	case *Gossip_Dig:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dig); err != nil {
			return err
		}
	case *Gossip_Ud:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ud); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Gossip.M has unexpected type %T", x)
	}
	return nil
}

func _Gossip_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Gossip)
	switch tag {
	case 3: // m.dig
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Gossip_Digest)
		err := b.DecodeMessage(msg)
		m.M = &Gossip_Dig{msg}
		return true, err
	case 4: // m.ud
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Gossip_Update)
		err := b.DecodeMessage(msg)
		m.M = &Gossip_Ud{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Gossip_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Gossip)
	// m
	switch x := m.M.(type) {
	case *Gossip_Dig:
		s := proto.Size(x.Dig)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Gossip_Ud:
		s := proto.Size(x.Ud)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Gossip_Digest struct {
	// string is used to represent peerID
	Data   map[string]*Gossip_Digest_PeerState `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Epoch  []byte                              `protobuf:"bytes,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	IsFull bool                                `protobuf:"varint,3,opt,name=isFull" json:"isFull,omitempty"`
	NoResp bool                                `protobuf:"varint,4,opt,name=noResp" json:"noResp,omitempty"`
}

func (m *Gossip_Digest) Reset()                    { *m = Gossip_Digest{} }
func (m *Gossip_Digest) String() string            { return proto.CompactTextString(m) }
func (*Gossip_Digest) ProtoMessage()               {}
func (*Gossip_Digest) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 0} }

func (m *Gossip_Digest) GetData() map[string]*Gossip_Digest_PeerState {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Gossip_Digest) GetEpoch() []byte {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *Gossip_Digest) GetIsFull() bool {
	if m != nil {
		return m.IsFull
	}
	return false
}

func (m *Gossip_Digest) GetNoResp() bool {
	if m != nil {
		return m.NoResp
	}
	return false
}

type Gossip_Digest_PeerState struct {
	State []byte `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	Num   uint64 `protobuf:"varint,2,opt,name=num" json:"num,omitempty"`
}

func (m *Gossip_Digest_PeerState) Reset()                    { *m = Gossip_Digest_PeerState{} }
func (m *Gossip_Digest_PeerState) String() string            { return proto.CompactTextString(m) }
func (*Gossip_Digest_PeerState) ProtoMessage()               {}
func (*Gossip_Digest_PeerState) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 0, 0} }

func (m *Gossip_Digest_PeerState) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Gossip_Digest_PeerState) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type Gossip_Update struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Gossip_Update) Reset()                    { *m = Gossip_Update{} }
func (m *Gossip_Update) String() string            { return proto.CompactTextString(m) }
func (*Gossip_Update) ProtoMessage()               {}
func (*Gossip_Update) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 1} }

func (m *Gossip_Update) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// TransactionBlock carries a batch of transactions.
type HotTransactionBlock struct {
	Transactions []*Transaction `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty"`
	BeginSeries  uint64         `protobuf:"varint,2,opt,name=beginSeries" json:"beginSeries,omitempty"`
}

func (m *HotTransactionBlock) Reset()                    { *m = HotTransactionBlock{} }
func (m *HotTransactionBlock) String() string            { return proto.CompactTextString(m) }
func (*HotTransactionBlock) ProtoMessage()               {}
func (*HotTransactionBlock) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

func (m *HotTransactionBlock) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *HotTransactionBlock) GetBeginSeries() uint64 {
	if m != nil {
		return m.BeginSeries
	}
	return 0
}

type PeerTxState struct {
	Digest      []byte `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	Num         uint64 `protobuf:"varint,2,opt,name=num" json:"num,omitempty"`
	Signature   []byte `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	Endorsement []byte `protobuf:"bytes,6,opt,name=endorsement,proto3" json:"endorsement,omitempty"`
}

func (m *PeerTxState) Reset()                    { *m = PeerTxState{} }
func (m *PeerTxState) String() string            { return proto.CompactTextString(m) }
func (*PeerTxState) ProtoMessage()               {}
func (*PeerTxState) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2} }

func (m *PeerTxState) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *PeerTxState) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *PeerTxState) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *PeerTxState) GetEndorsement() []byte {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

type Gossip_Tx struct {
	Txs map[string]*HotTransactionBlock `protobuf:"bytes,1,rep,name=txs" json:"txs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Gossip_Tx) Reset()                    { *m = Gossip_Tx{} }
func (m *Gossip_Tx) String() string            { return proto.CompactTextString(m) }
func (*Gossip_Tx) ProtoMessage()               {}
func (*Gossip_Tx) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{3} }

func (m *Gossip_Tx) GetTxs() map[string]*HotTransactionBlock {
	if m != nil {
		return m.Txs
	}
	return nil
}

type Gossip_TxState struct {
	Txs map[string]*PeerTxState `protobuf:"bytes,1,rep,name=txs" json:"txs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Gossip_TxState) Reset()                    { *m = Gossip_TxState{} }
func (m *Gossip_TxState) String() string            { return proto.CompactTextString(m) }
func (*Gossip_TxState) ProtoMessage()               {}
func (*Gossip_TxState) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{4} }

func (m *Gossip_TxState) GetTxs() map[string]*PeerTxState {
	if m != nil {
		return m.Txs
	}
	return nil
}

func init() {
	proto.RegisterType((*Gossip)(nil), "protos.Gossip")
	proto.RegisterType((*Gossip_Digest)(nil), "protos.Gossip.Digest")
	proto.RegisterType((*Gossip_Digest_PeerState)(nil), "protos.Gossip.Digest.PeerState")
	proto.RegisterType((*Gossip_Update)(nil), "protos.Gossip.Update")
	proto.RegisterType((*HotTransactionBlock)(nil), "protos.HotTransactionBlock")
	proto.RegisterType((*PeerTxState)(nil), "protos.PeerTxState")
	proto.RegisterType((*Gossip_Tx)(nil), "protos.Gossip_Tx")
	proto.RegisterType((*Gossip_TxState)(nil), "protos.Gossip_TxState")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GossipServer service

type GossipServerClient interface {
	// Request a new stream for bi-direction gossip
	// We must sent a peerId first for merging the stream with chatting,
	// This can't be achieve by protobuf and we had to imple it manually
	In(ctx context.Context, opts ...grpc.CallOption) (GossipServer_InClient, error)
}

type gossipServerClient struct {
	cc *grpc.ClientConn
}

func NewGossipServerClient(cc *grpc.ClientConn) GossipServerClient {
	return &gossipServerClient{cc}
}

func (c *gossipServerClient) In(ctx context.Context, opts ...grpc.CallOption) (GossipServer_InClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GossipServer_serviceDesc.Streams[0], c.cc, "/protos.GossipServer/In", opts...)
	if err != nil {
		return nil, err
	}
	x := &gossipServerInClient{stream}
	return x, nil
}

type GossipServer_InClient interface {
	Send(*Gossip) error
	Recv() (*Gossip, error)
	grpc.ClientStream
}

type gossipServerInClient struct {
	grpc.ClientStream
}

func (x *gossipServerInClient) Send(m *Gossip) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gossipServerInClient) Recv() (*Gossip, error) {
	m := new(Gossip)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GossipServer service

type GossipServerServer interface {
	// Request a new stream for bi-direction gossip
	// We must sent a peerId first for merging the stream with chatting,
	// This can't be achieve by protobuf and we had to imple it manually
	In(GossipServer_InServer) error
}

func RegisterGossipServerServer(s *grpc.Server, srv GossipServerServer) {
	s.RegisterService(&_GossipServer_serviceDesc, srv)
}

func _GossipServer_In_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GossipServerServer).In(&gossipServerInServer{stream})
}

type GossipServer_InServer interface {
	Send(*Gossip) error
	Recv() (*Gossip, error)
	grpc.ServerStream
}

type gossipServerInServer struct {
	grpc.ServerStream
}

func (x *gossipServerInServer) Send(m *Gossip) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gossipServerInServer) Recv() (*Gossip, error) {
	m := new(Gossip)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GossipServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.GossipServer",
	HandlerType: (*GossipServerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "In",
			Handler:       _GossipServer_In_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "gossip.proto",
}

func init() { proto.RegisterFile("gossip.proto", fileDescriptor6) }

var fileDescriptor6 = []byte{
	// 532 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0x51, 0x6f, 0xd3, 0x30,
	0x10, 0xc7, 0xe7, 0xa4, 0x0d, 0xcd, 0x35, 0x9a, 0x90, 0x07, 0x53, 0x14, 0x90, 0x56, 0xe5, 0x85,
	0x0e, 0xa1, 0x8a, 0xb5, 0x42, 0xa0, 0x3d, 0x4e, 0x03, 0x8a, 0x78, 0x41, 0x6e, 0x91, 0x78, 0x9b,
	0xdc, 0xc6, 0x84, 0x68, 0x69, 0x1c, 0x6c, 0x67, 0xb4, 0x5f, 0x02, 0x21, 0x3e, 0x14, 0x9f, 0x0b,
	0xd9, 0x4e, 0xba, 0x74, 0x2b, 0x3c, 0xd5, 0x77, 0xfe, 0xfb, 0xee, 0x77, 0xff, 0xab, 0x02, 0x41,
	0xca, 0xa5, 0xcc, 0xca, 0x51, 0x29, 0xb8, 0xe2, 0xd8, 0x33, 0x3f, 0x32, 0x0a, 0xbe, 0xd2, 0x85,
	0xc8, 0x96, 0x36, 0x1b, 0xff, 0x71, 0xc1, 0x7b, 0x6f, 0x64, 0xf8, 0x21, 0xb8, 0x92, 0x7d, 0x0f,
	0xd1, 0x00, 0x0d, 0x3b, 0x44, 0x1f, 0x71, 0x08, 0x0f, 0x96, 0x54, 0xd1, 0x9c, 0xa7, 0xa1, 0x33,
	0x40, 0x43, 0x9f, 0x34, 0x21, 0x3e, 0x05, 0x37, 0xc9, 0xd2, 0xd0, 0x1d, 0xa0, 0x61, 0x7f, 0xfc,
	0xd8, 0xd6, 0x92, 0x23, 0x5b, 0x68, 0x74, 0x99, 0xa5, 0x4c, 0xaa, 0xe9, 0x01, 0xd1, 0x1a, 0xfc,
	0x0c, 0x9c, 0x2a, 0x09, 0x3b, 0x7b, 0x95, 0x9f, 0xcb, 0x84, 0x2a, 0x36, 0x3d, 0x20, 0x4e, 0x95,
	0x44, 0xbf, 0x1d, 0xf0, 0xec, 0x53, 0x3c, 0x81, 0x4e, 0x42, 0x15, 0x0d, 0xd1, 0xc0, 0x1d, 0xf6,
	0xc7, 0x27, 0x7b, 0xeb, 0x8f, 0x2e, 0xa9, 0xa2, 0x6f, 0x0b, 0x25, 0x36, 0xc4, 0x88, 0xf1, 0x23,
	0xe8, 0xb2, 0x92, 0x2f, 0xbf, 0x19, 0xd6, 0x80, 0xd8, 0x00, 0x1f, 0x83, 0x97, 0xc9, 0x77, 0x55,
	0x9e, 0x1b, 0xd8, 0x1e, 0xa9, 0x23, 0x9d, 0x2f, 0x38, 0x61, 0xb2, 0x34, 0x68, 0x3d, 0x52, 0x47,
	0xd1, 0x04, 0xfc, 0x4f, 0x8c, 0x89, 0x99, 0xa2, 0x8a, 0xe9, 0x92, 0x52, 0x1f, 0x8c, 0x29, 0x01,
	0xb1, 0x81, 0x36, 0xaa, 0xa8, 0x56, 0xa6, 0x4d, 0x87, 0xe8, 0x63, 0xf4, 0x05, 0xfc, 0x2d, 0x8d,
	0xbe, 0xbe, 0x66, 0x1b, 0xf3, 0xc4, 0x27, 0xfa, 0x88, 0x5f, 0x41, 0xf7, 0x86, 0xe6, 0x15, 0x33,
	0x4f, 0xfe, 0x39, 0xcf, 0xb6, 0x2d, 0xb1, 0xea, 0x73, 0xe7, 0x0d, 0x8a, 0x62, 0xf0, 0xac, 0x49,
	0x7a, 0x19, 0x25, 0xdd, 0xe4, 0x9c, 0x26, 0x35, 0x4d, 0x13, 0x5e, 0xb8, 0x80, 0x56, 0x71, 0x09,
	0x47, 0x53, 0xae, 0xe6, 0x82, 0x16, 0x92, 0x2e, 0x55, 0xc6, 0x8b, 0x8b, 0x9c, 0x2f, 0xaf, 0xf1,
	0x6b, 0x08, 0xd4, 0x6d, 0x4e, 0xd6, 0x8e, 0x1e, 0x35, 0x04, 0x2d, 0x3d, 0xd9, 0x11, 0xe2, 0x01,
	0xf4, 0x17, 0x2c, 0xcd, 0x8a, 0x19, 0x13, 0x19, 0x93, 0xf5, 0xb0, 0xed, 0x54, 0xfc, 0x03, 0xfa,
	0x1a, 0x79, 0xbe, 0xb6, 0x5e, 0x1d, 0x83, 0x97, 0x98, 0x41, 0x6a, 0xbc, 0x3a, 0xba, 0xef, 0x16,
	0x7e, 0x0a, 0xbe, 0xcc, 0xd2, 0x82, 0xaa, 0x4a, 0xb0, 0xb0, 0x6b, 0xc4, 0xb7, 0x09, 0xdd, 0x98,
	0x15, 0x09, 0x17, 0x92, 0xad, 0x58, 0xa1, 0x42, 0xcf, 0xdc, 0xb7, 0x53, 0xf1, 0x4f, 0x04, 0xbe,
	0xb5, 0xee, 0x6a, 0xbe, 0xc6, 0x2f, 0xc0, 0x55, 0xeb, 0x66, 0xb0, 0x68, 0xd7, 0xda, 0xab, 0xf9,
	0x7a, 0x34, 0x5f, 0x4b, 0xfb, 0x2f, 0xd1, 0xb2, 0x68, 0x06, 0xbd, 0x26, 0xb1, 0x67, 0x51, 0x67,
	0xbb, 0x8b, 0x7a, 0xd2, 0x54, 0xdb, 0xe3, 0x6c, 0x6b, 0x49, 0xf1, 0x2f, 0x04, 0x87, 0xdb, 0x86,
	0xd6, 0x8d, 0xb3, 0x36, 0xd5, 0xc9, 0x3d, 0x2a, 0x23, 0xba, 0x83, 0xf6, 0xf1, 0xbf, 0x68, 0xa7,
	0xbb, 0x68, 0xdb, 0x0d, 0xb6, 0x56, 0xd0, 0x42, 0x1a, 0x9f, 0x43, 0x60, 0x9b, 0xcd, 0x98, 0xb8,
	0x61, 0x02, 0x3f, 0x07, 0xe7, 0x43, 0x81, 0x0f, 0x77, 0x41, 0xa2, 0x3b, 0x71, 0x7c, 0x30, 0x44,
	0x2f, 0xd1, 0xc2, 0x7e, 0x29, 0x26, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x8d, 0xad, 0xb1, 0x45,
	0x40, 0x04, 0x00, 0x00,
}
